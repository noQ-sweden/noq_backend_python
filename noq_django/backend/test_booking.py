from django.test import TestCase
from django.core.exceptions import ValidationError

# Generated by CodiumAI
from backend.models import Booking
from datetime import datetime
from backend.models import Product
from backend.models import BookingStatus
from backend.models import Available
from datetime import timedelta
from backend.models import Region, Client, User, Host, State


class test_Booking(TestCase):

    def setUp(self):

        region = Region(name="City")
        region.save()

        Host.objects.create(name="Host", city="City", region=region),

        # Create 4 male clients
        for i in range(4):
            user = User(username="mr_" + str(i))
            user.save()

            male_client = Client.objects.create(
                first_name="John",
                last_name="Doe",
                gender="M",
                street="123 Main St",
                postcode="12345",
                city="New York",
                country="USA",
                phone="123-456-7890",
                email="john.doe@example.com",
                unokod="ABC123",
                day_of_birth=datetime.now().date(),
                personnr_lastnr="1234",
                region=Region.objects.get(name="City"),
                requirements=None,
                last_edit=datetime.now().date(),
                user=user,
            )

        user = User(username="Mrs_1")
        user.save()
        female_client = Client.objects.create(
            first_name="Mary",
            last_name="Doe",
            gender="K",
            street="123 Main St",
            postcode="12345",
            city="New York",
            country="USA",
            phone="123-456-7890",
            email="john.doe@example.com",
            unokod="ABC123",
            day_of_birth=datetime.now().date(),
            personnr_lastnr="1234",
            region=Region.objects.get(name="City"),
            requirements=None,
            last_edit=datetime.now().date(),
            user=user,
        )

        # Create a woman-only product
        product = Product.objects.create(
            name="Product",
            description="Description",
            total_places=10,
            host=Host.objects.get(city="City"),
            type="woman-only",
            requirements=None,
        )

        # Create product with 1 total places
        product_one_place = Product.objects.create(
            name="ProductA",
            description="DescriptionA",
            total_places=1,
            host=Host.objects.get(city="City"),
            type="room",
            requirements=None,
        )

        # Create product with 5 total places
        product_five_places = Product.objects.create(
            name="ProductB",
            description="DescriptionB",
            total_places=5,
            host=Host.objects.get(city="City"),
            type="room",
            requirements=None,
        )


        status_objects = [
            BookingStatus(id=State.PENDING, description="pending"),
            BookingStatus(id=State.DECLINED, description="declined"),
            BookingStatus(id=State.ACCEPTED, description="accepted"),
            BookingStatus(id=State.CHECKED_IN, description="checked_in"),
            BookingStatus(id=State.IN_QUEUE, description="in_queue"),
            BookingStatus(id=State.RESERVED, description="reserved"),
            BookingStatus(id=State.CONFIRMED, description="confirmed"),
            BookingStatus(id=State.COMPLETED, description="completed"),
            BookingStatus(id=State.ADVISED_AGAINST, description="advised_against"),
        ]

        for status in status_objects:
            BookingStatus.objects.get_or_create(id=status.id, defaults={"description": status.description})

    # Booking a product with valid data saves the booking and updates availability
    def test_booking_with_valid_data(self):

        # Initialize a Booking object
        booking = Booking()

        # Set the attributes of the Booking object
        booking.start_date = datetime.now().date()
        booking.end_date = (datetime.now() + timedelta(days=3)).date()
        booking.product = Product.objects.first()
        booking.user = Client.objects.get(gender="K")
        booking.status = BookingStatus.objects.get(id=State.PENDING)

        # Save the Booking object
        booking.save()

        # Assert that the booking is saved
        assert Booking.objects.filter(id=booking.id).exists()

        # Assert that availability is updated
        availability = Available.objects.filter(
            product=booking.product, available_date=booking.start_date
        ).first()
        assert availability is not None
        assert availability.places_left == booking.product.total_places - 1

    # Booking a product with an invalid date raises ValidationError
    def test_booking_with_invalid_date(self):

        product = Product.objects.get(id=1)
        client = Client.objects.get(gender="K")
        status = BookingStatus.objects.first()

        # Initialize a Booking object
        booking = Booking()

        # Set the attributes of the Booking object with an invalid start_date
        booking.start_date = (datetime.now() - timedelta(days=1)).date()
        booking.end_date = (datetime.now() + timedelta(days=1)).date()
        booking.product = product
        booking.user = client
        booking.status = status

        # Assert that a ValidationError is raised when trying to save the booking
        with self.assertRaises(ValidationError):
            booking.save()

        # Set the attributes of the Booking object with an invalid end_date
        booking.start_date = datetime.now().date()
        booking.end_date = (datetime.now() - timedelta(days=1)).date()

        # Assert that a ValidationError is raised when trying to save the booking
        with self.assertRaises(ValidationError):
            booking.save()

    # Booking a product with a male user and woman-only type raises ValidationError
    def test_booking_with_male_user_and_woman_only_type_raises_validation_error(
        self,
    ):
        # Create a male user
        client = Client.objects.filter(gender="M").first()

        # Create a woman-only product
        product = Product.objects.create(
            name="Product",
            description="Description",
            total_places=10,
            host=Host.objects.get(city="City"),
            type="woman-only",
            requirements=None,
        )

        # Try to book the product with the male user
        with self.assertRaises(ValidationError):
            Booking.objects.create(
                start_date=datetime.now().date(),
                end_date=(datetime.now() + timedelta(days=1)).date(),
                product=product,
                user=client,
                status=BookingStatus.objects.create(description="pending"),
            )

    # Booking a product with the same user and date as the current
    # booking raises ValidationError
    def test_booking_with_same_user_and_date(self):
        # Create two bookings with valid data
        booking = Booking()
        booking.start_date = datetime.now().date()
        booking.end_date = (datetime.now() + timedelta(days=1)).date()
        booking.product = Product.objects.get(id=2)
        booking.user = Client.objects.get(gender="K")
        booking.status = BookingStatus.objects.get(id=State.PENDING)
        booking.save()

        # Try to create another booking with the same user and date
        duplicate_booking = Booking()
        duplicate_booking.start_date = booking.start_date
        duplicate_booking.end_date = (datetime.now() + timedelta(days=1)).date()
        duplicate_booking.product = booking.product
        duplicate_booking.user = Client.objects.get(gender="K")
        duplicate_booking.status = booking.status

        # Assert that a ValidationError is raised
        with self.assertRaises(ValidationError):
            duplicate_booking.save()

        # Assert that the original booking still exists
        assert Booking.objects.filter(id=booking.id).exists()

        # Assert that availability is not updated
        availability = Available.objects.filter(
            product=booking.product, available_date=booking.start_date
        ).first()
        assert availability is not None
        assert availability.places_left == booking.product.total_places - 1

    # Accepting a booking when out of places should raise error
    def test_booking_out_of_places(self):
        # Create two bookings with valid data, first one is accepted,
        # second is not accepted as there is no places left
        booking = Booking()
        booking.start_date = datetime.now().date()
        booking.end_date = (datetime.now() + timedelta(days=2)).date()
        booking.product = Product.objects.get(total_places=1)
        booking.user = Client.objects.get(id=1)
        booking.status = BookingStatus.objects.get(id=State.PENDING)
        booking.save()
        availability = Available.objects.filter(
            product=booking.product, available_date=booking.start_date
        ).first()
        assert availability is not None
        self.assertEqual(availability.places_left, 0)

        booking_2 = Booking()
        booking_2.start_date = datetime.now().date()
        booking_2.end_date = (datetime.now() + timedelta(days=2)).date()
        booking_2.product = Product.objects.get(total_places=1)
        booking_2.user = Client.objects.get(id=2)
        # It should not be possible to add second pending booking
        booking_2.status = BookingStatus.objects.get(id=State.PENDING)
        with self.assertRaises(ValidationError):
            booking_2.save()

        # Set second booking in queue, this should not change number of
        # available places
        booking_2.status = BookingStatus.objects.get(id=State.IN_QUEUE)
        booking_2.save()

        availability = Available.objects.filter(
            product=booking.product, available_date=booking.start_date
        ).first()
        assert availability is not None
        self.assertEqual(availability.places_left, 0)

        # Decline the first pending booking
        booking.status = BookingStatus.objects.get(id=State.DECLINED)
        booking.save()

        # After declining pending booking there should be available
        # places for booking
        availability = Available.objects.filter(
            product=booking.product, available_date=booking.start_date
        ).first()
        assert availability is not None
        self.assertEqual(availability.places_left, 1)

        booking_2.status = BookingStatus.objects.get(id=State.ACCEPTED)
        booking_2.save()
        # After booking is moved from queue to accepted there should
        # not be any places left for booking
        availability = Available.objects.filter(
            product=booking.product, available_date=booking.start_date
        ).first()
        assert availability is not None
        self.assertEqual(availability.places_left, 0)

    def test_prevent_overlapping_bookings(self):
            # Choose product of type B (The five rooms)
                product = Product.objects.get(name = "ProductB")
            # Test1: Validate that overlapping bookings trigger a ValidationError.
            # booking1 is set to start today and end in two days. 
            # booking2 is scheduled to start one day after booking1 begins and ends two days later.
            # Since booking2's start date falls within the duration of booking1, 
            # attempting to save booking2 should raise a ValidationError due to the overlap.
                booking1 = Booking()
                booking1.start_date = datetime.now().date()
                booking1.end_date = booking1.start_date + timedelta(days=2)
                booking1.product = product
                booking1.user = Client.objects.get(id=1)
                booking1.status = BookingStatus.objects.get(id=State.PENDING)
                booking1.save()

                booking2 = Booking()
                booking2.start_date = datetime.now().date() + timedelta(days=1)
                booking2.end_date = booking2.start_date + timedelta(days=2)
                booking2.product = product
                booking2.user = Client.objects.get(id=1)
                booking2.status = BookingStatus.objects.get(id=State.PENDING)

                with self.assertRaises(ValidationError):
                    booking2.save()
            # Test2: Verify that a new booking entirely within an existing booking raises a ValidationError.
            # booking3 starts in three days and lasts for four days. 
            # booking4 is set to start just one day after booking3 begins and ends two days after it starts(before the end booking 3). 
            # Since booking4's dates fall entirely within the duration of booking3, 
            # trying to save booking4 should raise a ValidationError due to the overlap.        
                booking3 = Booking()
                booking3.start_date = datetime.now().date() + timedelta(days=3)
                booking3.end_date = booking3.start_date + timedelta(days=4)
                booking3.product = product
                booking3.user = Client.objects.get(id=1)
                booking3.status = BookingStatus.objects.get(id=State.PENDING)
                booking3.save()

                booking4 = Booking()
                booking4.start_date = datetime.now().date() + timedelta(days=4)
                booking4.end_date = booking4.start_date + timedelta(days=2)
                booking4.product = product
                booking4.user = Client.objects.get(id=1)
                booking4.status = BookingStatus.objects.get(id=State.PENDING)

                with self.assertRaises(ValidationError):
                    booking4.save()   

    def create_five_bookings(self, test_date, product):
        '''
        Make 5 bookings in different timespans.
        day         012345678
        client1      |--|
        client2     |-----|
        client3        |----|
        client4     |------|
        client5       |--|
        available   321012345
        '''
        # Set data for bookings in a format that is easy to loop through
        test_data = [
            {'id': 1, 'start': 1, 'end': 4},
            {'id': 2, 'start': 0, 'end': 6},
            {'id': 3, 'start': 3, 'end': 8},
            {'id': 4, 'start': 0, 'end': 7},
            {'id': 5, 'start': 2, 'end': 5},
        ]
        clients = []
        # Create 5 bookings
        for i in range(5):
            client = Client.objects.get(id=test_data[i]['id'])
            clients.append(client)
            booking = Booking()
            booking.start_date = test_date + timedelta(days=test_data[i]['start'])
            booking.end_date = test_date + timedelta(days=test_data[i]['end'])
            booking.product = product
            booking.user = Client.objects.get(id=test_data[i]['id'])
            booking.status = BookingStatus.objects.get(id=State.PENDING)
            booking.save()
        return clients

    def test_that_availability_is_correct(self):
        '''
        Make 5 bookings in different timespans. Test that the
        availability is counted correctly for different days
        '''
        # Expected count for available places for each day
        expected_result = [3, 2, 1, 0, 1, 2, 3, 4, 5]
        # Select product with 5 places
        booked_product = Product.objects.get(total_places=5)
        # Set date
        test_date = datetime.now().date()
        # Create 5 bookings
        clients = self.create_five_bookings(test_date, booked_product)

        # Test that the availability is correct for each day
        for i in range(8):
            availability = Available.objects.filter(
                product=booked_product,
                available_date=test_date + timedelta(days=i)
            ).first()
            assert availability is not None
            self.assertEqual(availability.places_left, expected_result[i])

    def test_that_availability_is_correct_after_deletion(self):
        '''
        Make 5 bookings in different timespans. Test that the
        availability is counted correctly when bookings are deleted.

        - Step one: delete booking for client 1
        - Step two: delete booking for client 2
        - Step three: delete bookings for rest of the clients
        '''
        # Expected result for each day after deleting bookings
        expected_result = [
            [3, 3, 2, 1, 1, 2, 3, 4, 5], # Step 1
            [4, 4, 3, 2, 2, 3, 3, 4, 5], # Step 2
            [5, 5, 5, 5, 5, 5, 5, 5, 5]  # Step 3
        ]
        # Select product with 5 places
        booked_product = Product.objects.get(total_places=5)
        # Set date
        test_date = datetime.now().date()
        # Create 5 bookings
        clients = self.create_five_bookings(test_date, booked_product)

        # Test that the availability is correct for each day
        for i in range(3):
            if i > 1:
                # Step 3: Delete rest of the bookings
                booking = Booking.objects.all().delete()
            else:
                # Delete booking step 1 and step 2
                client = clients[i]
                booking = Booking.objects.filter(user=client).delete()

            for day_nr in range(8):
                availability = Available.objects.filter(
                    product=booked_product,
                    available_date=test_date + timedelta(days=day_nr)
                ).first()
                assert availability is not None
                self.assertEqual(availability.places_left, expected_result[i][day_nr])
